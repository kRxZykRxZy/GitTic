import { Router, type Request, type Response, type NextFunction } from "express";
import { requireAuth, optionalAuth } from "../middleware/auth-guard.js";
import { validate } from "../middleware/input-validator.js";
import * as projectRepo from "../db/repositories/project-repo.js";
import * as userRepo from "../db/repositories/user-repo.js";

/**
 * Issue management routes providing REST API endpoints for:
 * - Issue listing with advanced filtering and sorting
 * - Issue creation, retrieval, updating, and status management
 * - Issue comments and discussions
 * - Label management on issues
 * - Assignee management
 *
 * @module routes/issue-routes
 */
const router = Router();

/** Default pagination values. */
const DEFAULT_PAGE = 1;
const DEFAULT_PER_PAGE = 20;
const MAX_PER_PAGE = 100;

/** Supported sort fields for issue listings. */
const VALID_SORT_FIELDS = ["created", "updated", "comments", "title"];
const VALID_SORT_ORDERS = ["asc", "desc"];

/**
 * Clamp pagination parameters to safe ranges.
 *
 * @param query - The query parameters object from the request.
 * @returns An object with page and perPage values within safe bounds.
 */
function parsePagination(query: Record<string, unknown>): { page: number; perPage: number } {
  const page = Math.max(1, Number(query.page) || DEFAULT_PAGE);
  const perPage = Math.min(MAX_PER_PAGE, Math.max(1, Number(query.perPage) || DEFAULT_PER_PAGE));
  return { page, perPage };
}

/**
 * Resolve a project from owner username and repository slug.
 *
 * @param owner - The username of the repository owner.
 * @param repo - The repository slug.
 * @returns The project object or null if not found.
 */
function resolveRepository(owner: string, repo: string) {
  const user = userRepo.findByUsername(owner);
  if (!user) return null;
  return projectRepo.findBySlug(user.id, repo);
}

/**
 * Check if the requesting user can access a repository.
 * Public repositories are always accessible; private ones require owner or admin role.
 *
 * @param project - The project/repository object.
 * @param userId - The authenticated user's ID (optional).
 * @param role - The authenticated user's role (optional).
 * @returns True if the user can access the repository, false otherwise.
 */
function canAccessRepository(
  project: NonNullable<ReturnType<typeof projectRepo.findById>>,
  userId?: string,
  role?: string,
): boolean {
  if (!project.isPrivate) return true;
  if (!userId) return false;
  if (project.ownerId === userId) return true;
  if (role === "admin") return true;
  return false;
}

/**
 * Check if the requesting user can modify issues in a repository.
 * Requires either ownership or admin role.
 *
 * @param project - The project/repository object.
 * @param userId - The authenticated user's ID.
 * @param role - The authenticated user's role.
 * @returns True if the user can modify issues, false otherwise.
 */
function canModifyIssues(
  project: NonNullable<ReturnType<typeof projectRepo.findById>>,
  userId: string,
  role: string,
): boolean {
  return project.ownerId === userId || role === "admin";
}

/**
 * Validate sort parameters for issue listing.
 *
 * @param sortBy - The sort field name.
 * @param order - The sort order direction.
 * @returns Tuple of [sortBy, order] if valid, or [undefined, undefined] if invalid.
 */
function validateSort(sortBy?: string, order?: string): [string | undefined, string | undefined] {
  const validSortBy = sortBy && VALID_SORT_FIELDS.includes(sortBy) ? sortBy : undefined;
  const validOrder = order && VALID_SORT_ORDERS.includes(order.toLowerCase()) ? order.toLowerCase() : "desc";
  return [validSortBy, validOrder];
}

/**
 * Parse comma-separated filter values safely.
 *
 * @param value - The comma-separated string or undefined.
 * @returns Array of trimmed values or empty array.
 */
function parseFilterList(value?: string): string[] {
  if (!value) return [];
  return value
    .split(",")
    .map((item) => item.trim())
    .filter((item) => item.length > 0);
}

/* ── Issue Listing and Filtering ────────────────────────────────── */

/**
 * GET /api/repositories/:owner/:repo/issues
 *
 * List issues in a repository with advanced filtering and sorting capabilities.
 * Supports filtering by status, labels, assignees, and author.
 * Results are paginated with a default limit of 20 issues per page.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param status - Filter by issue status: 'open', 'closed', or 'all' (optional, defaults to 'open').
 * @param labels - Comma-separated list of label names to filter by (optional).
 * @param assignees - Comma-separated list of usernames to filter by (optional).
 * @param author - Filter by author username (optional).
 * @param sort - Sort by field: 'created', 'updated', 'comments', 'title' (optional, defaults to 'updated').
 * @param order - Sort order: 'asc' or 'desc' (optional, defaults to 'desc').
 * @param page - Page number for pagination (optional, defaults to 1).
 * @param perPage - Number of results per page (optional, defaults to 20).
 * @returns Array of issue objects with pagination metadata.
 *
 * @example
 * GET /api/repositories/john/my-project/issues
 * GET /api/repositories/john/my-project/issues?status=closed
 * GET /api/repositories/john/my-project/issues?labels=bug,urgent&assignees=john,jane
 * GET /api/repositories/john/my-project/issues?sort=created&order=asc&page=2
 */
router.get(
  "/:owner/:repo/issues",
  optionalAuth,
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const { page, perPage } = parsePagination(req.query as Record<string, unknown>);

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      const status = (req.query.status as string | undefined)?.toLowerCase() || "open";
      const labels = parseFilterList(req.query.labels as string | undefined);
      const assignees = parseFilterList(req.query.assignees as string | undefined);
      const author = (req.query.author as string | undefined)?.trim();
      const [sortBy, order] = validateSort(
        req.query.sort as string | undefined,
        req.query.order as string | undefined,
      );

      // Validate status parameter
      if (!["open", "closed", "all"].includes(status)) {
        res.status(400).json({
          error: "Invalid status. Must be 'open', 'closed', or 'all'",
          code: "VALIDATION_ERROR",
        });
        return;
      }

      // TODO: Implement issue listing with filtering using database queries
      // This would typically query the issues table with the given filters
      const total = 0;
      const totalPages = Math.ceil(total / perPage);

      res.set("X-Total-Count", String(total));
      res.set("X-Total-Pages", String(totalPages));
      res.set("X-Current-Page", String(page));
      res.set("X-Per-Page", String(perPage));

      res.json({
        data: [],
        pagination: { page, perPage, total, totalPages },
        filters: {
          status,
          labels: labels.length > 0 ? labels : undefined,
          assignees: assignees.length > 0 ? assignees : undefined,
          author: author || undefined,
        },
        sort: {
          by: sortBy,
          order,
        },
      });
    } catch (err) {
      next(err);
    }
  },
);

/* ── Issue Details ───────────────────────────────────────────────── */

/**
 * GET /api/repositories/:owner/:repo/issues/:number
 *
 * Retrieve detailed information about a specific issue,
 * including title, description, labels, assignees, and current status.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number (sequential identifier).
 * @returns Issue object with full metadata.
 *
 * @example
 * GET /api/repositories/john/my-project/issues/42
 */
router.get(
  "/:owner/:repo/issues/:number",
  optionalAuth,
  validate([{ field: "number", location: "params", type: "string", pattern: /^\d+$/ }]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement issue detail retrieval
      // This would typically query the issues table for the given issue number
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "open",
        author: {
          id: "",
          username: "",
          avatar: null,
        },
        assignees: [],
        labels: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/* ── Issue Creation ──────────────────────────────────────────────── */

/**
 * POST /api/repositories/:owner/:repo/issues
 *
 * Create a new issue in a repository. The user must be authenticated.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @body title - Issue title (required, max 255 characters).
 * @body description - Issue description (optional, max 10000 characters).
 * @body labels - Array of label names to assign (optional).
 * @body assignees - Array of usernames to assign (optional).
 * @returns Newly created issue object.
 *
 * @example
 * POST /api/repositories/john/my-project/issues
 * {
 *   "title": "Add dark mode support",
 *   "description": "Implement dark mode theme for better user experience",
 *   "labels": ["feature", "ui"],
 *   "assignees": ["jane"]
 * }
 */
router.post(
  "/:owner/:repo/issues",
  requireAuth,
  validate([
    { field: "title", location: "body", required: true, type: "string", min: 1, max: 255 },
    { field: "description", location: "body", type: "string", max: 10000 },
    { field: "labels", location: "body", type: "object" },
    { field: "assignees", location: "body", type: "object" },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const { title, description, labels, assignees } = req.body as {
        title: string;
        description?: string;
        labels?: string[];
        assignees?: string[];
      };

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement issue creation
      // This would typically insert a new record into the issues table
      const issue = {
        id: "",
        number: 1,
        title,
        description: description || null,
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: assignees || [],
        labels: labels || [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      };

      res.status(201).json(issue);
    } catch (err) {
      next(err);
    }
  },
);

/* ── Issue Updates ───────────────────────────────────────────────── */

/**
 * PATCH /api/repositories/:owner/:repo/issues/:number
 *
 * Update an existing issue. Only the issue author or repository owner can update.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @body title - New issue title (optional).
 * @body description - New issue description (optional).
 * @body labels - Array of label names to set (optional).
 * @body assignees - Array of usernames to set (optional).
 * @returns Updated issue object.
 *
 * @example
 * PATCH /api/repositories/john/my-project/issues/42
 * {
 *   "title": "Add dark mode support and accessibility features",
 *   "description": "Updated description with more details"
 * }
 */
router.patch(
  "/:owner/:repo/issues/:number",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "title", location: "body", type: "string", min: 1, max: 255 },
    { field: "description", location: "body", type: "string", max: 10000 },
    { field: "labels", location: "body", type: "object" },
    { field: "assignees", location: "body", type: "object" },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const { title, description, labels, assignees } = req.body as {
        title?: string;
        description?: string;
        labels?: string[];
        assignees?: string[];
      };

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement issue update
      // This would typically fetch the issue, check permissions, and update fields
      // Verify that the user is either the issue author or the repository owner
      res.json({
        id: "",
        number,
        title: title || "",
        description: description || null,
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: assignees || [],
        labels: labels || [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/* ── Issue Status Management ────────────────────────────────────── */

/**
 * POST /api/repositories/:owner/:repo/issues/:number/close
 *
 * Close an open issue. Only the issue author or repository owner can close.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @body reason - Optional reason for closing (optional).
 * @returns Updated issue object with status set to 'closed'.
 *
 * @example
 * POST /api/repositories/john/my-project/issues/42/close
 * {
 *   "reason": "Fixed in v1.2.0"
 * }
 */
router.post(
  "/:owner/:repo/issues/:number/close",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "reason", location: "body", type: "string", max: 1000 },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement issue closing
      // This would typically fetch the issue, check permissions, and set status to 'closed'
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "closed",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: [],
        labels: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/**
 * POST /api/repositories/:owner/:repo/issues/:number/reopen
 *
 * Reopen a closed issue. Only the issue author or repository owner can reopen.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @body reason - Optional reason for reopening (optional).
 * @returns Updated issue object with status set to 'open'.
 *
 * @example
 * POST /api/repositories/john/my-project/issues/42/reopen
 * {
 *   "reason": "Issue still present in latest version"
 * }
 */
router.post(
  "/:owner/:repo/issues/:number/reopen",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "reason", location: "body", type: "string", max: 1000 },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement issue reopening
      // This would typically fetch the issue, check permissions, and set status to 'open'
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: [],
        labels: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/* ── Issue Comments ──────────────────────────────────────────────── */

/**
 * GET /api/repositories/:owner/:repo/issues/:number/comments
 *
 * List all comments on an issue, sorted chronologically by creation date.
 * Results are paginated with a default limit of 20 comments per page.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @param page - Page number for pagination (optional, defaults to 1).
 * @param perPage - Number of results per page (optional, defaults to 20).
 * @returns Array of comment objects with pagination metadata.
 *
 * @example
 * GET /api/repositories/john/my-project/issues/42/comments
 * GET /api/repositories/john/my-project/issues/42/comments?page=2&perPage=50
 */
router.get(
  "/:owner/:repo/issues/:number/comments",
  optionalAuth,
  validate([{ field: "number", location: "params", type: "string", pattern: /^\d+$/ }]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const { page, perPage } = parsePagination(req.query as Record<string, unknown>);

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement comment listing
      // This would typically query the issue comments table filtered by issue number
      const total = 0;
      const totalPages = Math.ceil(total / perPage);

      res.set("X-Total-Count", String(total));
      res.set("X-Total-Pages", String(totalPages));
      res.set("X-Current-Page", String(page));
      res.set("X-Per-Page", String(perPage));

      res.json({
        data: [],
        pagination: { page, perPage, total, totalPages },
      });
    } catch (err) {
      next(err);
    }
  },
);

/**
 * POST /api/repositories/:owner/:repo/issues/:number/comments
 *
 * Add a new comment to an issue. The user must be authenticated.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @body body - Comment text (required, max 5000 characters).
 * @returns Newly created comment object.
 *
 * @example
 * POST /api/repositories/john/my-project/issues/42/comments
 * {
 *   "body": "This is a great issue. I suggest we implement it as follows..."
 * }
 */
router.post(
  "/:owner/:repo/issues/:number/comments",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "body", location: "body", required: true, type: "string", min: 1, max: 5000 },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const { body } = req.body as { body: string };

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement comment creation
      // This would typically insert a new record into the comments table
      const comment = {
        id: "",
        issueNumber: number,
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        body,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      res.status(201).json(comment);
    } catch (err) {
      next(err);
    }
  },
);

/* ── Comment Management ──────────────────────────────────────────── */

/**
 * PATCH /api/repositories/:owner/:repo/issues/comments/:commentId
 *
 * Update an existing comment. Only the comment author or repository owner can update.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param commentId - Comment unique identifier.
 * @body body - New comment text (required, max 5000 characters).
 * @returns Updated comment object.
 *
 * @example
 * PATCH /api/repositories/john/my-project/issues/comments/comment-123
 * {
 *   "body": "Updated comment with corrected information"
 * }
 */
router.patch(
  "/:owner/:repo/issues/comments/:commentId",
  requireAuth,
  validate([
    { field: "commentId", location: "params", type: "string", min: 1 },
    { field: "body", location: "body", required: true, type: "string", min: 1, max: 5000 },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const commentId = String(req.params.commentId);
      const { body } = req.body as { body: string };

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement comment update
      // This would typically fetch the comment, verify permissions, and update the body
      // The user must be either the comment author or the repository owner
      const comment = {
        id: commentId,
        issueNumber: 0,
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        body,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      };

      res.json(comment);
    } catch (err) {
      next(err);
    }
  },
);

/**
 * DELETE /api/repositories/:owner/:repo/issues/comments/:commentId
 *
 * Delete a comment from an issue. Only the comment author or repository owner can delete.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param commentId - Comment unique identifier.
 * @returns Success message.
 *
 * @example
 * DELETE /api/repositories/john/my-project/issues/comments/comment-123
 */
router.delete(
  "/:owner/:repo/issues/comments/:commentId",
  requireAuth,
  validate([{ field: "commentId", location: "params", type: "string", min: 1 }]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const commentId = String(req.params.commentId);

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement comment deletion
      // This would typically fetch the comment, verify permissions, and delete it
      // The user must be either the comment author or the repository owner
      res.json({ message: `Comment '${commentId}' deleted successfully` });
    } catch (err) {
      next(err);
    }
  },
);

/* ── Label Management ────────────────────────────────────────────── */

/**
 * POST /api/repositories/:owner/:repo/issues/:number/labels
 *
 * Add labels to an issue. Only the issue author or repository owner can add labels.
 * Labels that don't exist in the repository will be created automatically.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @body labels - Array of label names to add (required, non-empty).
 * @returns Updated issue object with the newly added labels.
 *
 * @example
 * POST /api/repositories/john/my-project/issues/42/labels
 * {
 *   "labels": ["bug", "urgent", "p0"]
 * }
 */
router.post(
  "/:owner/:repo/issues/:number/labels",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "labels", location: "body", required: true, type: "object" },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const { labels } = req.body as { labels: string[] };

      if (!Array.isArray(labels) || labels.length === 0) {
        res.status(400).json({
          error: "Labels must be a non-empty array",
          code: "VALIDATION_ERROR",
        });
        return;
      }

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement label addition
      // This would typically fetch the issue, verify permissions,
      // create any non-existent labels, and add them to the issue
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: [],
        labels,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/**
 * DELETE /api/repositories/:owner/:repo/issues/:number/labels/:label
 *
 * Remove a label from an issue. Only the issue author or repository owner can remove labels.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @param label - Label name (URL-encoded if it contains special characters).
 * @returns Updated issue object with the label removed.
 *
 * @example
 * DELETE /api/repositories/john/my-project/issues/42/labels/urgent
 * DELETE /api/repositories/john/my-project/issues/42/labels/help-wanted
 */
router.delete(
  "/:owner/:repo/issues/:number/labels/:label",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "label", location: "params", type: "string", min: 1, max: 100 },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const label = decodeURIComponent(String(req.params.label));

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement label removal
      // This would typically fetch the issue, verify permissions, and remove the label
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: [],
        labels: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/* ── Assignee Management ──────────────────────────────────────────── */

/**
 * POST /api/repositories/:owner/:repo/issues/:number/assignees
 *
 * Add assignees to an issue. Only the issue author or repository owner can assign.
 * The assignee must be a valid user who has access to the repository.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @body assignees - Array of usernames to assign (required, non-empty).
 * @returns Updated issue object with the newly assigned users.
 *
 * @example
 * POST /api/repositories/john/my-project/issues/42/assignees
 * {
 *   "assignees": ["jane", "bob"]
 * }
 */
router.post(
  "/:owner/:repo/issues/:number/assignees",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "assignees", location: "body", required: true, type: "object" },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const { assignees } = req.body as { assignees: string[] };

      if (!Array.isArray(assignees) || assignees.length === 0) {
        res.status(400).json({
          error: "Assignees must be a non-empty array",
          code: "VALIDATION_ERROR",
        });
        return;
      }

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // Verify that all assignees exist
      for (const username of assignees) {
        const assigneeUser = userRepo.findByUsername(username);
        if (!assigneeUser) {
          res.status(400).json({
            error: `User '${username}' not found`,
            code: "USER_NOT_FOUND",
          });
          return;
        }
      }

      // TODO: Implement assignee addition
      // This would typically fetch the issue, verify permissions,
      // and add the users as assignees
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: assignees.map((username) => ({
          id: "",
          username,
          avatar: null,
        })),
        labels: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

/**
 * DELETE /api/repositories/:owner/:repo/issues/:number/assignees/:username
 *
 * Remove an assignee from an issue. Only the issue author or repository owner can unassign.
 *
 * @param owner - Repository owner's username.
 * @param repo - Repository slug.
 * @param number - Issue number.
 * @param username - Username of the assignee to remove.
 * @returns Updated issue object with the assignee removed.
 *
 * @example
 * DELETE /api/repositories/john/my-project/issues/42/assignees/jane
 */
router.delete(
  "/:owner/:repo/issues/:number/assignees/:username",
  requireAuth,
  validate([
    { field: "number", location: "params", type: "string", pattern: /^\d+$/ },
    { field: "username", location: "params", type: "string", min: 1, max: 255 },
  ]),
  (req: Request, res: Response, next: NextFunction) => {
    try {
      const owner = String(req.params.owner).toLowerCase();
      const repo = String(req.params.repo).toLowerCase();
      const number = parseInt(String(req.params.number), 10);
      const username = String(req.params.username).toLowerCase();

      const project = resolveRepository(owner, repo);
      if (!project) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      if (!canAccessRepository(project, req.user?.userId, req.user?.role)) {
        res.status(404).json({ error: "Repository not found", code: "NOT_FOUND" });
        return;
      }

      // TODO: Implement assignee removal
      // This would typically fetch the issue, verify permissions, and remove the assignee
      res.json({
        id: "",
        number,
        title: "",
        description: "",
        status: "open",
        author: {
          id: req.user!.userId,
          username: req.user!.username,
          avatar: null,
        },
        assignees: [],
        labels: [],
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        commentCount: 0,
      });
    } catch (err) {
      next(err);
    }
  },
);

export default router;
