/**
 * Suspicious login detection.
 * Detects impossible travel, new device logins, unusual time patterns,
 * and brute force attempts to protect user accounts.
 * @module security/login-detector
 */

/**
 * Login event data for analysis.
 */
export interface LoginEvent {
  /** User ID */
  userId: string;
  /** Timestamp of the login */
  timestamp: number;
  /** IP address */
  ipAddress: string;
  /** User agent string */
  userAgent: string;
  /** Whether the login was successful */
  success: boolean;
  /** Approximate latitude (if available) */
  latitude: number | null;
  /** Approximate longitude (if available) */
  longitude: number | null;
  /** Country code (if available) */
  countryCode: string | null;
  /** Device fingerprint/ID */
  deviceId: string | null;
}

/**
 * Suspicion alert generated by the detector.
 */
export interface SuspicionAlert {
  /** Alert type */
  type: SuspicionType;
  /** Severity level */
  severity: "low" | "medium" | "high" | "critical";
  /** User ID affected */
  userId: string;
  /** Human-readable description */
  message: string;
  /** The login event that triggered the alert */
  triggeringEvent: LoginEvent;
  /** Related events that contributed to the alert */
  relatedEvents: LoginEvent[];
  /** Timestamp of the alert */
  timestamp: number;
  /** Recommended action */
  recommendedAction: string;
}

/**
 * Types of suspicious activity that can be detected.
 */
export type SuspicionType =
  | "impossible_travel"
  | "new_device"
  | "unusual_time"
  | "brute_force"
  | "credential_stuffing"
  | "new_country"
  | "rapid_failures";

/**
 * Configuration for the login detector.
 */
export interface LoginDetectorConfig {
  /** Maximum speed in km/h for travel detection (default: 900) */
  maxTravelSpeedKmh?: number;
  /** Number of failed attempts to trigger brute force alert (default: 5) */
  bruteForceThreshold?: number;
  /** Time window for brute force detection in ms (default: 5 minutes) */
  bruteForceWindowMs?: number;
  /** Normal login hours (start, end) in 24h format (default: 6-23) */
  normalHoursStart?: number;
  /** Normal login hours end (default: 23) */
  normalHoursEnd?: number;
  /** Number of rapid failures to flag (default: 10) */
  rapidFailureThreshold?: number;
  /** Time window for rapid failure detection in ms (default: 1 minute) */
  rapidFailureWindowMs?: number;
  /** Maximum events to retain per user (default: 100) */
  maxEventsPerUser?: number;
}

/**
 * Default detector configuration.
 */
const DETECTOR_DEFAULTS: Required<LoginDetectorConfig> = {
  maxTravelSpeedKmh: 900,
  bruteForceThreshold: 5,
  bruteForceWindowMs: 5 * 60 * 1000,
  normalHoursStart: 6,
  normalHoursEnd: 23,
  rapidFailureThreshold: 10,
  rapidFailureWindowMs: 60 * 1000,
  maxEventsPerUser: 100,
};

/**
 * Calculate the distance between two geographic points using the Haversine formula.
 * @param lat1 - Latitude of point 1 in degrees
 * @param lon1 - Longitude of point 1 in degrees
 * @param lat2 - Latitude of point 2 in degrees
 * @param lon2 - Longitude of point 2 in degrees
 * @returns Distance in kilometers
 */
export function haversineDistance(
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number {
  const R = 6371; // Earth's radius in km
  const dLat = ((lat2 - lat1) * Math.PI) / 180;
  const dLon = ((lon2 - lon1) * Math.PI) / 180;
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos((lat1 * Math.PI) / 180) *
      Math.cos((lat2 * Math.PI) / 180) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

/**
 * Suspicious login detector.
 * Analyzes login events to detect potentially malicious activity.
 */
export class LoginDetector {
  private readonly config: Required<LoginDetectorConfig>;
  private readonly events = new Map<string, LoginEvent[]>();
  private readonly alerts: SuspicionAlert[] = [];
  private readonly knownDevices = new Map<string, Set<string>>();
  private readonly knownCountries = new Map<string, Set<string>>();

  /**
   * Create a new login detector.
   * @param config - Detection configuration
   */
  constructor(config: LoginDetectorConfig = {}) {
    this.config = {
      maxTravelSpeedKmh:
        config.maxTravelSpeedKmh ?? DETECTOR_DEFAULTS.maxTravelSpeedKmh,
      bruteForceThreshold:
        config.bruteForceThreshold ??
        DETECTOR_DEFAULTS.bruteForceThreshold,
      bruteForceWindowMs:
        config.bruteForceWindowMs ?? DETECTOR_DEFAULTS.bruteForceWindowMs,
      normalHoursStart:
        config.normalHoursStart ?? DETECTOR_DEFAULTS.normalHoursStart,
      normalHoursEnd:
        config.normalHoursEnd ?? DETECTOR_DEFAULTS.normalHoursEnd,
      rapidFailureThreshold:
        config.rapidFailureThreshold ??
        DETECTOR_DEFAULTS.rapidFailureThreshold,
      rapidFailureWindowMs:
        config.rapidFailureWindowMs ??
        DETECTOR_DEFAULTS.rapidFailureWindowMs,
      maxEventsPerUser:
        config.maxEventsPerUser ?? DETECTOR_DEFAULTS.maxEventsPerUser,
    };
  }

  /**
   * Analyze a login event and generate alerts if suspicious.
   * @param event - Login event to analyze
   * @returns Array of suspicion alerts generated
   */
  analyzeLogin(event: LoginEvent): SuspicionAlert[] {
    const newAlerts: SuspicionAlert[] = [];

    // Store the event
    let userEvents = this.events.get(event.userId);
    if (!userEvents) {
      userEvents = [];
      this.events.set(event.userId, userEvents);
    }

    // Check for impossible travel
    const travelAlert = this.checkImpossibleTravel(event, userEvents);
    if (travelAlert) newAlerts.push(travelAlert);

    // Check for new device
    const deviceAlert = this.checkNewDevice(event);
    if (deviceAlert) newAlerts.push(deviceAlert);

    // Check for unusual time
    const timeAlert = this.checkUnusualTime(event);
    if (timeAlert) newAlerts.push(timeAlert);

    // Check for brute force
    const bruteForceAlert = this.checkBruteForce(event, userEvents);
    if (bruteForceAlert) newAlerts.push(bruteForceAlert);

    // Check for rapid failures (credential stuffing)
    const rapidAlert = this.checkRapidFailures(event, userEvents);
    if (rapidAlert) newAlerts.push(rapidAlert);

    // Check for new country
    const countryAlert = this.checkNewCountry(event);
    if (countryAlert) newAlerts.push(countryAlert);

    // Store event after analysis
    userEvents.push(event);
    while (userEvents.length > this.config.maxEventsPerUser) {
      userEvents.shift();
    }

    // Register device and country
    if (event.success) {
      if (event.deviceId) {
        let devices = this.knownDevices.get(event.userId);
        if (!devices) {
          devices = new Set();
          this.knownDevices.set(event.userId, devices);
        }
        devices.add(event.deviceId);
      }
      if (event.countryCode) {
        let countries = this.knownCountries.get(event.userId);
        if (!countries) {
          countries = new Set();
          this.knownCountries.set(event.userId, countries);
        }
        countries.add(event.countryCode);
      }
    }

    // Store alerts
    this.alerts.push(...newAlerts);

    return newAlerts;
  }

  /**
   * Check for impossible travel between two login locations.
   * @param event - Current login event
   * @param previousEvents - Previous login events for this user
   * @returns Alert or null
   */
  private checkImpossibleTravel(
    event: LoginEvent,
    previousEvents: LoginEvent[]
  ): SuspicionAlert | null {
    if (event.latitude === null || event.longitude === null) {
      return null;
    }

    const recentSuccess = [...previousEvents]
      .reverse()
      .find(
        (e) =>
          e.success &&
          e.latitude !== null &&
          e.longitude !== null
      );

    if (!recentSuccess) return null;

    const distance = haversineDistance(
      recentSuccess.latitude!,
      recentSuccess.longitude!,
      event.latitude,
      event.longitude
    );

    const timeDiffHours =
      (event.timestamp - recentSuccess.timestamp) / (1000 * 60 * 60);

    if (timeDiffHours <= 0) return null;

    const requiredSpeed = distance / timeDiffHours;

    if (requiredSpeed > this.config.maxTravelSpeedKmh) {
      return {
        type: "impossible_travel",
        severity: "high",
        userId: event.userId,
        message: `Impossible travel detected: ${Math.round(distance)}km in ${timeDiffHours.toFixed(1)}h (${Math.round(requiredSpeed)}km/h)`,
        triggeringEvent: event,
        relatedEvents: [recentSuccess],
        timestamp: Date.now(),
        recommendedAction:
          "Require additional verification (MFA) or block the login",
      };
    }

    return null;
  }

  /**
   * Check if a login is from a new/unknown device.
   * @param event - Login event
   * @returns Alert or null
   */
  private checkNewDevice(event: LoginEvent): SuspicionAlert | null {
    if (!event.deviceId || !event.success) return null;

    const knownDevices = this.knownDevices.get(event.userId);
    if (!knownDevices || knownDevices.size === 0) return null;

    if (!knownDevices.has(event.deviceId)) {
      return {
        type: "new_device",
        severity: "medium",
        userId: event.userId,
        message: "Login from a new/unrecognized device",
        triggeringEvent: event,
        relatedEvents: [],
        timestamp: Date.now(),
        recommendedAction:
          "Send notification to user and optionally require MFA",
      };
    }

    return null;
  }

  /**
   * Check if a login occurs at an unusual time.
   * @param event - Login event
   * @returns Alert or null
   */
  private checkUnusualTime(event: LoginEvent): SuspicionAlert | null {
    if (!event.success) return null;

    const hour = new Date(event.timestamp).getHours();
    const isNormalHour =
      hour >= this.config.normalHoursStart &&
      hour < this.config.normalHoursEnd;

    if (!isNormalHour) {
      return {
        type: "unusual_time",
        severity: "low",
        userId: event.userId,
        message: `Login at unusual hour: ${hour}:00`,
        triggeringEvent: event,
        relatedEvents: [],
        timestamp: Date.now(),
        recommendedAction: "Monitor for additional suspicious activity",
      };
    }

    return null;
  }

  /**
   * Check for brute force attack patterns.
   * @param event - Login event
   * @param previousEvents - Previous events for this user
   * @returns Alert or null
   */
  private checkBruteForce(
    event: LoginEvent,
    previousEvents: LoginEvent[]
  ): SuspicionAlert | null {
    if (event.success) return null;

    const windowStart =
      event.timestamp - this.config.bruteForceWindowMs;
    const recentFailures = previousEvents.filter(
      (e) => !e.success && e.timestamp >= windowStart
    );

    if (recentFailures.length + 1 >= this.config.bruteForceThreshold) {
      return {
        type: "brute_force",
        severity: "critical",
        userId: event.userId,
        message: `Brute force detected: ${recentFailures.length + 1} failed attempts in ${this.config.bruteForceWindowMs / 1000}s`,
        triggeringEvent: event,
        relatedEvents: recentFailures,
        timestamp: Date.now(),
        recommendedAction:
          "Lock the account temporarily and notify the user",
      };
    }

    return null;
  }

  /**
   * Check for rapid failure patterns (credential stuffing).
   * @param event - Login event
   * @param previousEvents - Previous events
   * @returns Alert or null
   */
  private checkRapidFailures(
    event: LoginEvent,
    previousEvents: LoginEvent[]
  ): SuspicionAlert | null {
    if (event.success) return null;

    const windowStart =
      event.timestamp - this.config.rapidFailureWindowMs;
    const rapidFails = previousEvents.filter(
      (e) =>
        !e.success &&
        e.timestamp >= windowStart &&
        e.ipAddress === event.ipAddress
    );

    if (
      rapidFails.length + 1 >=
      this.config.rapidFailureThreshold
    ) {
      return {
        type: "credential_stuffing",
        severity: "critical",
        userId: event.userId,
        message: `Rapid failures from same IP: ${rapidFails.length + 1} in ${this.config.rapidFailureWindowMs / 1000}s`,
        triggeringEvent: event,
        relatedEvents: rapidFails,
        timestamp: Date.now(),
        recommendedAction: "Block the IP address and investigate",
      };
    }

    return null;
  }

  /**
   * Check if a login is from a new country.
   * @param event - Login event
   * @returns Alert or null
   */
  private checkNewCountry(event: LoginEvent): SuspicionAlert | null {
    if (!event.countryCode || !event.success) return null;

    const knownCountries = this.knownCountries.get(event.userId);
    if (!knownCountries || knownCountries.size === 0) return null;

    if (!knownCountries.has(event.countryCode)) {
      return {
        type: "new_country",
        severity: "medium",
        userId: event.userId,
        message: `Login from new country: ${event.countryCode}`,
        triggeringEvent: event,
        relatedEvents: [],
        timestamp: Date.now(),
        recommendedAction:
          "Send notification and consider requiring additional verification",
      };
    }

    return null;
  }

  /**
   * Get all alerts for a user.
   * @param userId - User ID
   * @returns Array of alerts
   */
  getAlerts(userId?: string): SuspicionAlert[] {
    if (userId) {
      return this.alerts.filter((a) => a.userId === userId);
    }
    return [...this.alerts];
  }

  /**
   * Get recent events for a user.
   * @param userId - User ID
   * @param limit - Maximum events to return
   * @returns Recent login events
   */
  getRecentEvents(
    userId: string,
    limit: number = 20
  ): LoginEvent[] {
    const events = this.events.get(userId) ?? [];
    return events.slice(-limit);
  }

  /**
   * Clear all events and alerts for a user.
   * @param userId - User ID
   */
  clearUserData(userId: string): void {
    this.events.delete(userId);
    this.knownDevices.delete(userId);
    this.knownCountries.delete(userId);
  }
}
